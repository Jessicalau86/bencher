#![allow(clippy::unwrap_used)]

use std::{fmt, io::Write};

use async_openai::{
    types::{ChatCompletionRequestMessageArgs, CreateChatCompletionRequestArgs, Role},
    Client,
};
use camino::Utf8PathBuf;

use crate::parser::{CliLanguage, CliTranslate};

const GITHUB_ISSUE_URL_STR: &str = "https://github.com/bencherdev/bencher/issues/new";

// https://platform.openai.com/docs/models/gpt-4
const GPT4_MODEL: &str = "gpt-4-0613";

#[derive(Debug)]
pub struct Translate {
    pub input_path: Utf8PathBuf,
    pub lang: CliLanguage,
    pub output_path: Option<Utf8PathBuf>,
    pub disclosure: bool,
}

impl TryFrom<CliTranslate> for Translate {
    type Error = anyhow::Error;

    fn try_from(translate: CliTranslate) -> Result<Self, Self::Error> {
        let CliTranslate {
            input_path,
            lang,
            output_path,
            disclosure,
        } = translate;
        Ok(Self {
            input_path,
            lang,
            output_path,
            disclosure,
        })
    }
}

impl fmt::Display for CliLanguage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                CliLanguage::German => "German",
                CliLanguage::Spanish => "Spanish",
                CliLanguage::French => "French",
                CliLanguage::Japanese => "Japanese",
                CliLanguage::Portuguese => "Portuguese",
                CliLanguage::Russian => "Russian",
                CliLanguage::Chinese => "Simplified Chinese",
            }
        )
    }
}

impl CliLanguage {
    // Returns the ISO 639-1 language code for the language
    fn iso_code(self) -> &'static str {
        match self {
            CliLanguage::German => "de",
            CliLanguage::Spanish => "es",
            CliLanguage::French => "fr",
            CliLanguage::Japanese => "ja",
            CliLanguage::Portuguese => "pt",
            CliLanguage::Russian => "ru",
            CliLanguage::Chinese => "zh",
        }
    }
}

impl Translate {
    #[allow(clippy::unused_async)]
    pub async fn exec(&self) -> anyhow::Result<()> {
        let lang = self.lang;

        let content_path = Utf8PathBuf::from("services/console/src/");
        let input_path = content_path.join(&self.input_path);
        let output_path = self.output_path.clone().unwrap_or_else(|| {
            let mut output_path =
                // dir/content/section/en/example.md
                input_path
                // dir/content/section/en/
                .parent()
                .unwrap()
                // dir/content/section/
                .parent()
                .unwrap()
                .to_path_buf();
            // content/section/[lang]/
            output_path.push(lang.iso_code());
            std::fs::create_dir_all(&output_path).unwrap();
            // content/section/[lang]/example.md
            output_path.push(self.input_path.file_name().unwrap());
            output_path
        });
        println!("From: {input_path}");
        println!("  To: {output_path}");
        println!("Lang: {lang}");

        let system_input = format!("You are a professional translator for software documentation. Translate the Markdown (MDX with frontmatter metadata) text provided by the user from American English to {lang}. Do NOT translate any of the text inside of Markdown or HTML code blocks nor any URL strings. Keep in mind that the audience for the translation is software developers.");
        let issue_url = github_issue_url(lang, &self.input_path);
        let input = std::fs::read_to_string(&input_path)?;
        let disclosure = if self.disclosure {
            format!(
                r#"<div class="box" style="margin-top: 4rem;">This document was automatically generated by OpenAI GPT-4. It might not be accurate and might contain errors. If you find any errors, please <a href="{issue_url}" target="_blank">open an issue on GitHub</a>.</div>"#,
            )
        } else {
            String::new()
        };
        let user_input = format!("{input}{disclosure}");

        let client = Client::new();
        // https://platform.openai.com/docs/models/model-endpoint-compatibility
        let request = CreateChatCompletionRequestArgs::default()
            .model(GPT4_MODEL)
            .messages([
                ChatCompletionRequestMessageArgs::default()
                    .role(Role::System)
                    .content(&system_input)
                    .build()?,
                ChatCompletionRequestMessageArgs::default()
                    .role(Role::User)
                    .content(&user_input)
                    .build()?,
            ])
            .build()?;
        let response = client.chat().create(request).await?;

        println!("\nResponse:\n");
        let mut translation = String::new();
        #[allow(clippy::use_debug)]
        for choice in response.choices {
            println!(
                "{}: Role: {}  Content: {:?}",
                choice.index, choice.message.role, choice.message.content
            );
            translation.push_str(&choice.message.content.unwrap_or_default());
        }

        let mut f = std::fs::File::create(output_path)?;
        f.write_all(translation.as_bytes()).unwrap();

        Ok(())
    }
}

pub fn github_issue_url(lang: CliLanguage, file_path: &Utf8PathBuf) -> url::Url {
    let mut url: url::Url = GITHUB_ISSUE_URL_STR.parse().unwrap();
    let title = format!("Issue with translation to {lang}");
    let body = format!("Issue with translation to {lang} for {file_path}.");
    let query = serde_urlencoded::to_string([
        ("title", title.as_str()),
        ("body", body.as_str()),
        ("labels", "documentation"),
    ])
    .ok();
    url.set_query(query.as_deref());
    url
}
