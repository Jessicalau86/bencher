## 지속적인 벤치마킹 vs 로컬 벤치마크 비교

여러 벤치마크 하네스들은 결과를 로컬에서 비교할 수 있게 해줍니다.
로컬 비교는 성능 튜닝을 위해 빠르게 반복 작업을 할 때 유용합니다.
그러나, 이는 지속적으로 성능 회귀를 포착하는 데 의존되어서는 안됩니다.
단위 테스트를 로컬에서 실행할 수 있는 것이 CI의 필요성을 제거하는 것처럼,
벤치마크를 로컬에서 실행하고 비교할 수 있는 것이 CB의 필요성을 제거하진 않습니다.

Bencher가 제공하는 여러 기능들은 로컬 벤치마크 비교 도구들이 할 수 없는 것들입니다:
- 다른 테스트베드 간에 동일한 벤치마크 비교
- 언어 및 하네스 간 벤치마크 비교
- 벤치마크 결과의 협업 및 공유
- 노이즈 최소화를 위한 전용 테스트베드에서의 벤치마크 실행
- 더 이상 템플릿 복사는 필요 없음

## 지속적인 벤치마킹 vs 애플리케이션 성능 관리 (APM)

애플리케이션 성능 관리(APM)는 현대 소프트웨어 서비스에 필수적인 도구입니다.
그러나 APM은 실제 환경에서 사용하기 위해 설계되었습니다.
성능 회귀가 탐지될 때까지, 그것은 이미 고객에게 영향을 미치고 있습니다.

> 대부분의 결함은 추방하는 데 드는 비용보다 더 많이 듭니다.
> 결함이 발생할 때마다 비용이 들며, 결함을 수정하는 직접적인 비용
> 그리고 손상된 관계, 잃어버린 사업, 그리고 잃어버린 개발 시간으로 인한 간접 비용이 있습니다.
>
> — Kent Beck, 익스트림 프로그래밍 설명

Bencher가 APM 도구들이 할 수 없는 여러 기능들을 제공합니다:
- 성능 회귀를 _생산 환경으로 넘어가기 전에_ 탐지하고 방지
- 코드 리뷰에 포함된 성능 변화 및 영향
- 생산 환경에서의 오버헤드 없음
- 사내 배포에 효과적
- 생산 소스 코드 변경 없음

## 지속적인 벤치마킹 vs 옵저버빌리티

다른 이름으로 불린다해도 장미는 여전히 달콤하게 냄새납니다.
'지속적인 벤치마킹 vs 애플리케이션 성능 관리'를 참조하세요.

## 지속적인 벤치마킹 vs 지속적인 통합 (CI)

지속적인 벤치마킹 (CB)은 지속적인 통합 (CI)을 보완합니다.
코드 변경마다 단위 테스트가 CI에서 실행되는 것과 같은 이유로,
성능 테스트는 코드 변경마다 CB에서 실행되어야 합니다.

> 지금은 단위 테스트와 수용 테스트가 범용적으로 표준 개발 사례로 받아들여졌지만,
> 이러한 추세가 성능 테스트 영역으로 확장되진 않았습니다.
> 현재, 일반적인 툴링은 테스터들을 일회용 코드 생성과 클릭-스크립트 방식으로 몰아넣습니다.
> 성능 테스트를 일급 시민으로 취급하게 되면, 더 많은 기능을 다루는 더 나은 테스트를 만들 수 있어,
> 더 나은 툴링을 통해 성능 테스트를 생성하고 실행할 수 있게 되고,
> 유지 관리가 가능하며 자체 테스트가 가능한 테스트 스위트를 만들 수 있게 됩니다.
>
> — [Thoughtworks Technology Radar, 2013년 5월 22일](https://www.thoughtworks.com/en-us/radar/techniques/performance-testing-as-a-first-class-citizen)

<br/>
<br/>

<h2><a href="/docs/ko/tutorial/quick-start">계속 진행하십시오: 빠른 시작 ➡</a></h2>